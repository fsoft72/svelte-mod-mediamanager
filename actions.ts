/* This file is autogenerated by liwe3-svelte */
/* eslint-disable @typescript-eslint/no-inferrable-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unused-vars */

/*=== f2c_start __file ===*/

/*=== f2c_end __file ===*/

import { get, patch, post, delete_, type LiWEFetcherOptions } from '$liwe3/utils/fetcher';

/**
 * Use this to start a new chunked upload.
 * The chunked upload is used to upload very big files.
 * This call will instruct the server to receive a new chunked file.
 * During this call you have to provide the original `filename` and the whole upload `size` in bytes.
 * The endpoint will return the `id_upload` that must be used for the next chunked transfer calls.
 * If the payload contains the `anonymous` value, then the user doesn't need to be logged in to upload files.
 *
 * @param id_folder - The ID Folder where to upload the media [req]
 * @param filename - Original filename [req]
 * @param size - Complete file size in bytes [req]
 * @param title - The media title [opt]
 * @param tags - The media tags [opt]
 * @param anonymous - If it is set, you don't need permissions [opt]
 *
 * @return id_upload: str
 *
 */
export const media_upload_chunk_start = async ( id_folder: string, filename: string, size: number, title?: string, tags?: string[], anonymous?: string, _options?: LiWEFetcherOptions ) => {
	const res = await post( `/api/media/upload/chunk/start`, { 
		anonymous,
		filename,
		id_folder,
		size,
		tags,
		title
	 }, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_upload_chunk_start ===*/

	/*=== f2c_end media_upload_chunk_start ===*/

	return res.id_upload;
};

/**
 * This call will add a new chunk to the file being uploaded.
 * In the query field you have to provide:
 * - `id_upload`:   the upload id you got with the `/media/upload/chunk/start` call
 * - `start`:  the start position of this chunk (in bytes)
 * In the `post` section, you have to provide an `application/octet-stream` of your binary chunk data.
 *
 * @param id_upload - The id_upload [req]
 * @param start - The starting point [req]
 *
 * @return bytes: int
 *
 */
export const media_upload_chunk_add = async ( id_upload: string, start: number, _options?: LiWEFetcherOptions ) => {
	const res = await post( `/api/media/upload/chunk/add?id_upload=${id_upload}&start=${start}`, {}, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_upload_chunk_add ===*/

	/*=== f2c_end media_upload_chunk_add ===*/

	return res.bytes;
};

/**
 * Creates a new folder
 *
 * @param id_parent - The parent folder [req]
 * @param name - The folder name [req]
 *
 * @return folder: MediaFolder
 *
 */
export const media_folder_create = async ( id_parent: string, name: string, _options?: LiWEFetcherOptions ) => {
	const res = await post( `/api/media/folder/create`, { id_parent, name }, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_folder_create ===*/

	/*=== f2c_end media_folder_create ===*/

	return res.folder;
};

/**
 * Renames a folder
 *
 * @param id_folder -  [req]
 * @param name - The new folder name [req]
 *
 * @return folder: MediaFolder
 *
 */
export const media_folder_rename = async ( id_folder: string, name: string, _options?: LiWEFetcherOptions ) => {
	const res = await patch( `/api/media/folder/rename`, { id_folder, name }, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_folder_rename ===*/

	/*=== f2c_end media_folder_rename ===*/

	return res.folder;
};

/**
 * This endpoint deletes the provided folder along with all the subfolders and all the media contained.
 *
 * @param id_folder - The ID folder to delete [req]
 *
 * @return ok: boolean
 *
 */
export const media_folder_delete = async ( id_folder: string, _options?: LiWEFetcherOptions ) => {
	const res = await delete_( `/api/media/folder/delete`, { id_folder }, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_folder_delete ===*/

	/*=== f2c_end media_folder_delete ===*/

	return res.ok;
};

/**
 * Returns the root folder (related to the user `domain`)
 *
 *
 * @return folder: MediaFolder
 *
 */
export const media_folder_root = async ( _options?: any ) => {
	const res = await get( `/api/media/folder/root`, {}, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_folder_root ===*/

	/*=== f2c_end media_folder_root ===*/

	return res.folder;
};

/**
 * This endpoints can returns all elements of the specified `id_folder`.
 * If `id_folder` is not specified, all media are returned.
 *
 * @param id_folders - The ID Folders we want media from [opt]
 *
 * @return medias: Media
 *
 */
export const media_list = async ( id_folders?: string[], _options?: LiWEFetcherOptions ) => {
	const res = await get( `/api/media/list`, { id_folders }, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_list ===*/

	/*=== f2c_end media_list ===*/

	return res.medias;
};

/**
 * @param id - The media ID [req]
 *
 * @return media: Media
 *
 */
export const media_get = async ( id: string, _options?: LiWEFetcherOptions ) => {
	const res = await get( `/api/media/get`, { id }, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_get ===*/

	/*=== f2c_end media_get ===*/

	return res.media;
};

/**
 * Returns a tree of folders starting from the `id_folder` provided.
 * If not `id_folder` is provided, the `root` folder will be used.
 * The tree returned will contain all folders and subfolders, but not the files.
 *
 * @param id_folder - The starting ID folder [opt]
 *
 * @return tree: MediaFolder
 *
 */
export const media_folders_tree = async ( id_folder?: string, _options?: LiWEFetcherOptions ) => {
	const res = await get( `/api/media/folders/tree`, { id_folder }, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_folders_tree ===*/

	/*=== f2c_end media_folders_tree ===*/

	return res.tree;
};

/**
 * This endpoint deletes from the filesystem all the items specified inside the `medias`.\
 * Each item specified is the `id` of a media item
 *
 * @param medias - An array of ID media to be deleted [req]
 *
 * @return deleted: int
 *
 */
export const media_delete_items = async ( medias: string[], _options?: LiWEFetcherOptions ) => {
	const res = await delete_( `/api/media/delete/items`, { medias }, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_delete_items ===*/

	/*=== f2c_end media_delete_items ===*/

	return res.deleted;
};

/**
 * This method allows the upload of one or more files, using the *classical* way of uploading of `POST` files.
 *
 * @param title - The media title [opt]
 * @param module - The module the file belongs to [opt]
 * @param id_folder - Destination Folder id [opt]
 * @param tags - File tags [opt]
 *
 * @return media: Media
 *
 */
export const media_upload = async ( title?: string, module?: string, id_folder?: string, tags?: string[], _options?: LiWEFetcherOptions ) => {
	const res = await post( `/api/media/upload`, { 
		id_folder,
		module,
		tags,
		title
	 }, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_upload ===*/

	/*=== f2c_end media_upload ===*/

	return res.media;
};

/**
 * Performs a query for one or more of the given fields
 *
 * @param title - Media title [opt]
 * @param name - Media name [opt]
 * @param type - Media type [opt]
 * @param tags - Media tags [opt]
 * @param year - Media creation year [opt]
 * @param skip - Pagination start [opt]
 * @param rows - How many rows to return [opt]
 *
 * @return medias: Media
 *
 */
export const media_search = async ( title?: string, name?: string, type?: string, tags?: string[], year?: number, skip: number = 0, rows: number = 50, _options?: LiWEFetcherOptions ) => {
	const res = await get( `/api/media/search`, { 
		name,
		rows,
		skip,
		tags,
		title,
		type,
		year
	 }, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_search ===*/

	/*=== f2c_end media_search ===*/

	return res.medias;
};

/**
 * @param skip - The starting point [opt]
 * @param rows - How many items to retrieve [opt]
 *
 * @return medias: Media
 *
 */
export const media_get_latest = async ( skip: number = 0, rows: number = 50, _options?: LiWEFetcherOptions ) => {
	const res = await get( `/api/media/get/latest`, { skip, rows }, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_get_latest ===*/

	/*=== f2c_end media_get_latest ===*/

	return res.medias;
};

/**
 * Updates the media metadata
 *
 * @param id - Media id [req]
 * @param title - Media title [opt]
 * @param tags - Media tags [opt]
 *
 * @return media: Media
 *
 */
export const media_meta_update = async ( id: string, title?: string, tags?: string[], _options?: LiWEFetcherOptions ) => {
	const res = await patch( `/api/media/meta/update`, { id, title, tags }, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_meta_update ===*/

	/*=== f2c_end media_meta_update ===*/

	return res.media;
};

/**
 * @param id - The media ID [opt]
 *
 * @return ok: boolean
 *
 */
export const media_download = async ( id?: string, _options?: LiWEFetcherOptions ) => {
	const res = await get( `/api/media/download?id=${id}`, {}, _options?.skipError ? _options.skipError : false );

	if (res.error) return res;

	/*=== f2c_start media_download ===*/

	/*=== f2c_end media_download ===*/

	return res.ok;
};
